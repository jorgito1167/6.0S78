import random
from utils import *
from TreeNode import *
from CollisionBox import *

class RRT():

    def __init__(self,start, goal, collision_box, dimensions,metric, node_step = 3, max_count= 10000):
        self.goal = goal
        self.start = TreeNode(start,None)
        self.collision_box = collision_box
        self.dimensions = dimensions
        self.nodes = [self.start]
        self.node_step = node_step
        self.max_count = max_count
        self.metric = metric
    
  
    '''
    Produces a random configuration using the dimensions provided
    '''
    def randConfig(self):
        config = []
        for i in xrange(len(self.dimensions)):
            config.append(random.uniform(self.dimensions[i][0],self.dimensions[i][1]))
        return config
    
    '''
    find the nearest node
    '''
    def findNearNode(self, config):
        q = Queue()
        q.push(self.start)
        current_min = self.metric(self.start.state,config) 
        min_node = self.start
        while not q.isEmpty():
            node = q.pop()
            d = self.metric(node.state,config)
            for c in node.children:
                q.push(c)
            if d < current_min:
                current_min = d
                min_node = node
        return node
                


    '''
    steps the a given configuration towards the a new configuration
    '''
    def step(self, oldConfig, newConfig):
        step = []
        limits = 0
        for i in xrange(len(oldConfig)):
            diff = newConfig[i] - oldConfig[i]
            newDimension = oldConfig[i] + math.copysign(self.dimensions[i][2], diff)
            if abs(newDimension) < abs(oldConfig[i]):
                step.append(oldConfig + self.dimensions[i][2])
            else:
                step.append(oldConfig[i])
                limits += 1
        if limits == len(self.dimensions):
            return None
        else:
            return step
        

    '''
    Once you have the nearest node, step to the new node and check for collisions.
    Then, expand the tree by adding nodes along the path.
    '''
    def stepAndExpand(self, q_near, q_rand):
        next_step = q_near.state    #configuration
        node = q_near     #node
        node_step = self.node_step
        collision = False
        print "START EXPAND \n"
        while next_step!= None and (not collision):
            print q_rand
            print next_step
            next_step = self.step(next_step, q_rand) #configuration
            print next_step
            if next_step!=None:
                collision = self.collision_box.collides(next_step)

                if node_step == 0 and (not collision):
                    node_step = self.node_step
                    new_node = TreeNode(next_step,node)
                    node.addChild(new_node)
                    node = new_node

            else:
                node_step -= 1 

        if next_step== None and (not collision):
            return True

        else:
            return False

    def draw(self):
        self.start.draw()

    def run(self):
        goal_count = 0
        max_count = self.max_count
        while max_count > 0:
            max_count -=1
            if goal_count == 10:
                goal_count = 0
                q_rand = self.goal
            else:
                goal_count += 1
                q_rand = self.randConfig()
    
            q_near_node = self.findNearNode(q_rand)
            connected = self.stepAndExpand(q_near_node, q_rand)
            if connected and goal_count ==0:
                break
